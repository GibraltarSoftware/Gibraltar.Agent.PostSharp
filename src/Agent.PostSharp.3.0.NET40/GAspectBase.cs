using System;
using System.Diagnostics;
using System.Reflection;
using System.Text;
using PostSharp.Aspects;

namespace Gibraltar.Agent.PostSharp
{
    /// <summary>
    /// Base class for most Gibraltar Agent for PostSharp aspects (except for
    /// GField).
    /// </summary>
    [DebuggerNonUserCode]
    [Serializable]
    public abstract class GAspectBase : OnMethodBoundaryAspect, IMessageSourceProvider
    {
        private const int IndentSize = 2;
        private string m_MethodName;
        private string m_ClassName;

        [NonSerialized] //we need this to be figured out at runtime.
        private static string s_DefaultCategoryBase;

        private string m_BaseCategory;

        #region Public Properties and Methods

        /// <summary>
        /// The top level category for log messages and metrics.  Defaults to the name of the current application.
        /// </summary>
        public string BaseCategory
        {
            get
            {
                //we have to have a value, so if they set it to null or it got reserialized that way then return our default.
                return string.IsNullOrEmpty(m_BaseCategory) ? DefaultBaseCategory : m_BaseCategory;
            }
            set
            {
                m_BaseCategory = value; 
            }
        }

        #endregion

        #region Protected Propeties and Methods

        /// <summary>
        /// A display caption that is calculated at compile time
        /// rather then runtime for efficiency.
        /// </summary>
        protected string CaptionName { get; set;}


        /// <summary>
        /// Calculate the category from the root to the beginning of the autogenerated category.
        /// </summary>
        /// <remarks>
        /// 	<para>By default the base category will be a combination of the current application
        ///     name and a constant string depending on
        ///     whether this is a call to get the base category for a metric or a log message. By
        ///     overriding this method you can substitute your own method of calculating this value
        ///     and then set the category parameter to reflect your choice.</para>
        /// 	<para>If you set an invalid (generally null or empty) value the default will be
        ///     used.</para>
        /// </remarks>
        /// <param name="category">The default category for the current aspect, replace with your own non-empty value to override.</param>
        protected virtual void OnBaseCategoryCalculate(ref string category)
        {
            //by default we do nothing - we already decorated the category before it was passed in.
        }

        /// <summary>
        /// Infrastructure.  Safely determine the base category path for the current aspect.  Will always return a non-empty value.
        /// </summary>
        /// <returns>A non-empty category without the trailing period.</returns>
        protected string GetBaseCategory(string subCategory)
        {
            //set up our default value
            string category;
            if (string.IsNullOrEmpty(subCategory))
            {
                category = BaseCategory;
            }
            else
            {
                category = BaseCategory + "." + subCategory;
            }
            string defaultValue = category; //so we can reset it downstream if there's an issue.

            //now ask them to add to it
            try
            {
                OnBaseCategoryCalculate(ref category);
            }
            catch 
            {
                //if they fail, we use our default.
                category = defaultValue;
            }

            //and clean it up if they changed it.
            if (string.IsNullOrEmpty(category))
                category = defaultValue;

            //if it starts or ends with a period fix that.
            if (category.StartsWith("."))
            {
                category = category.Remove(0, 1);
            }

            if (category.EndsWith("."))
            {
                category = category.Remove(category.Length - 1, 1);
            }

            return category;
        }

        /// <summary>
        /// Process an arbitrary object instance into a string representation.
        /// </summary>
        /// <param name="value">An object to represent as a string, such as a return value.</param>
        /// <param name="getObjectDetails">True to get object details by evaluating ToString() even on class types.
        /// False to avoid calling ToString() on class types (still used for struct and enum types).</param>
        /// <returns>A string representing the provided object.</returns>
        internal static string ObjectToString(object value, bool getObjectDetails)
        {
            string valueString = null;
            if (value == null)
            {
                valueString = "(null)";
            }
            else
            {
                Type parameterType = value.GetType();
                if (parameterType.IsClass == false)
                {
                    // Structs and enums should always have efficient ToString implementations, we assume.
                    if (parameterType.IsEnum)
                    {
                        //we want to pop the enum class name in front of the value to make it clear.
                        valueString = parameterType.Name + "." + value.ToString();
                    }
                    else
                    {
                        valueString = value.ToString();
                    }
                }
                else if (parameterType == typeof(string))
                {
                    valueString = (string)value; // Use the value itself if it's already a string.
                }
                else
                {
                    if (getObjectDetails) // Before we call ToString() on a class instance...
                    {
                        valueString = value.ToString(); // Only evaluate ToString() of a class instance if logging details.

                        if (string.IsNullOrEmpty(valueString))
                        {
                            valueString = null; //and we don't need to do the next check...
                        }
                        else if (valueString.StartsWith(parameterType.Namespace + "." + parameterType.Name)) //if it's a generic type then it will have MORE than the full name.
                        {
                            valueString = null; // It's just the base object ToString implementation; we can improve on this.
                        }
                        // Otherwise, we'll keep the result of ToString to describe this object.
                    }

                    if (valueString == null) // If not logging details or if ToString was simply the type...
                    {
                        // Replace it with the type name and hash code to distinguish polymorphism and instance.
                        valueString = string.Format("{{{0}[0x{1:X8}]}}", parameterType.Namespace + "." + parameterType.Name, value.GetHashCode());
                    }
                }
            }

            return valueString;
        }

        /// <summary>
        /// Produce an array of the same length processed into strings.
        /// </summary>
        /// <param name="array">An array of objects, such as a parameter list.</param>
        /// <param name="getObjectDetails">True to get object details by evaluating ToString() even on class types.
        /// False to avoid calling ToString() on class types (still used for struct and enum types).</param>
        /// <returns>An array of strings representing each item in the provided array.</returns>
        protected static string[] ObjectArrayToStrings(object[] array, bool getObjectDetails)
        {
            if (array == null)
                return null;

            int arrayLength = array.Length;
            string[] stringArray = new string[arrayLength];
            for (int i = 0; i < arrayLength; i++)
                stringArray[i] = ObjectToString(array[i], getObjectDetails);

            return stringArray;
        }

        #endregion

        #region IMessageSourceProvider

        // IMessageSourceProvider is a Gibrlatar interface.  We define it here to
        // suppress Gibraltar's normal source code attribution logic.

        /// <summary>
        /// MethodName is part of the IMessageSourceProvider interface.
        /// In the case that source lookup is being skipped for efficiency,
        /// we can still provide method and class name from information known
        /// at compilation.
        /// </summary>
        string IMessageSourceProvider.MethodName { get { return m_MethodName; } }

        /// <summary>
        /// ClassName is part of the IMessageSourceProvider interface.
        /// In the case that source lookup is being skipped for efficiency,
        /// we can still provide method and class name from information known
        /// at compilation.
        /// </summary>
        string IMessageSourceProvider.ClassName { get { return m_ClassName; } }

        /// <summary>
        /// FileName is part of the IMessageSourceProvider interface.
        /// In the case that source lookup is being skipped for efficiency,
        /// we return null for FileName.
        /// </summary>
        string IMessageSourceProvider.FileName { get { return null; } }

        /// <summary>
        /// LineNumber is part of the IMessageSourceProvider interface.
        /// In the case that source lookup is being skipped for efficiency,
        /// we return zero for LineNumber.
        /// </summary>
        int IMessageSourceProvider.LineNumber { get { return 0; } }

        #endregion

        /// <summary>
        /// PostSharp Infrastructure.  The method stores values that will allow
        /// for faster run-time execution.
        /// </summary>
        public override void CompileTimeInitialize(MethodBase method, AspectInfo info)
        {
            // This will be reported in the Class column of Gibraltar Analyst
            m_ClassName = method.DeclaringType.Namespace + "." + method.DeclaringType.Name;

            // This will be reported in the Method column of Gibraltar Analyst
            m_MethodName = method.Name;

            CaptionName = method.DeclaringType.Name + "." + method.Name;
        }


        #region Internal Properties and Methods

        internal static string Indent(string text)
        {
            // Use indentation to show nesting level
            StringBuilder builder = new StringBuilder();
            int indentLevel = Trace.IndentLevel;
            builder.Append(' ', indentLevel*IndentSize);
            builder.Append(text);
            return builder.ToString();
        }

        internal static MetricValueType GetMetricValueType(Type type)
        {
            if (type.IsByRef)
                type = type.GetElementType();

            if (type == typeof(System.Byte) ||
                type == typeof(System.Int16) ||
                type == typeof(System.Int32) ||
                type == typeof(System.Int64) ||
                type == typeof(System.Single) ||
                type == typeof(System.Double) ||
                type == typeof(System.Decimal))
            {
                return MetricValueType.Numeric;
            }
            else if (type == typeof(System.Boolean))
            {
                return MetricValueType.Boolean;
            }
            else
            {
                return MetricValueType.NotNumeric;
            }
        }

        internal enum MetricValueType
        {
            Numeric,
            Boolean,
            NotNumeric
        }

        internal static string DefaultBaseCategory
        {
            get
            {
                if (s_DefaultCategoryBase == null)
                {
                    s_DefaultCategoryBase = Log.SessionSummary.Application;
                }

                return s_DefaultCategoryBase;
            }
        }

        #endregion
    }
}